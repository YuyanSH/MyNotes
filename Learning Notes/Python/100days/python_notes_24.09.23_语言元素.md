1.计算机的硬件系统：运算器、控制器、存储器、输入设备、输出设备。运算器+控制器=中央处理器。
冯诺依曼架构：一是指出存储设备与中央处理器分开，二是提出了将数据以二进制的形式进行编码

2.变量和类型
*整型
*浮点型
*字符串型：用单引号或双引号括起来的任意文本，例如'hello'或"hello"。
*布尔型：只有True与False两种类型，python中可以直接用True、False表示布尔型(注意大小写)，也可以通过布尔运算计算出来（例如3 < 5会产生布尔值True，而2 == 1会产生布尔值False）
*复数型：例如：3+5j

变量使用，type()函数可以对变量的类型进行检查，例如：
a = 12.3
print(type(a))   #<class 'int'>

可以使用下列函数对变量类型进行转换
int()：将一个数值或字符串转换成整数，可以指定进制。
float()：将一个字符串转换成浮点数。
str()：将指定的对象转换成字符串形式，可以指定编码。
chr()：将整数转换成该编码对应的字符串（一个字符）。
ord()：将字符串（一个字符）转换成对应的编码（整数）。

`a = int(input('a = '))`
`b = int(input('b = '))`
`print('%d + %d = %d' % (a, b, a + b))`
`print('%d - %d = %d' % (a, b, a - b))`
`print('%d * %d = %d' % (a, b, a * b))`
`print('%d / %d = %f' % (a, b, a / b))`
`print('%d // %d = %d' % (a, b, a // b))`
`print('%d  %d = %d' % (a, b, a % b))`
`print('%d ** %d = %d' % (a, b, a ** b))`
上面的print函数中输出的字符串使用了占位符语法，其中%d是整数的占位符，%f是小数的占位符，表示百分号（因为百分号代表了占位符，所以带占位符的字符串中要表示百分号必须写成），字符串之后的%后面跟的变量值会替换掉占位符然后输出到终端中

3.运算符
运算符优先级从高到低排列如下:
 :	下标，切片
**	指数
~ + -	按位取反, 正负号
/ % //	乘，除，模，整除
-	加，减
<<	右移，左移
&	按位与
^ |	按位异或，按位或
<= < > >=	小于等于，小于，大于，大于等于
== !=	等于，不等于
is is not	身份运算符
in not in	成员运算符
not or and	逻辑运算符
= += -= = /= %= //= = &= 	= ^= >>= <<=
如果搞不清运算符的优先级，可以使用括号来确保运算的执行顺序。

赋值运算符
将右边的值赋给左边的变量
`a = 10`
`b = 3`
`a += b        # 相当于：a = a + b`
`a = a + 2    # 相当于：a = a * (a + 2)`
`print(a)      # 算一下这里会输出什么`

比较运算符与逻辑运算符
比较运算符也称为关系运算符，包括、!=、<、>、<=、>=。比较运算符会产生布尔值，要么是True要么是False。
逻辑运算符有三个，分别是and、or和not。and字面意思是“而且”，所以and运算符会连接两个布尔值，如果两个布尔值都是True，那么运算的结果就是True；左右两边的布尔值有一个是False，最终的运算结果就是False。相信大家已经想到了，如果and左边的布尔值是False，不管右边的布尔值是什么，最终的结果都是False，所以在做运算的时候右边的值会被跳过（短路处理），这也就意味着在and运算符左边为False的情况下，右边的表达式根本不会执行。or字面意思是“或者”，所以or运算符也会连接两个布尔值，如果两个布尔值有任意一个是True，那么最终的结果就是True。当然，or运算符也是有短路功能的，在它左边的布尔值为True的情况下，右边的表达式根本不会执行。not运算符的后面会跟上一个布尔值，它的作用是得到与该布尔值相反的值，也就是说，后面的布尔值如果是True运算结果就是False，而后面的布尔值如果是False则运算结果就是True
`flag0 = 1 == 1`
`flag1 = 3 > 2`
`flag2 = 2 < 1`
`flag3 = flag1 and flag2`
`flag4 = flag1 or flag2`
`flag5 = not (1 != 2)`
`print('flag0 =', flag0)    # flag0 = True`
`print('flag1 =', flag1)    # flag1 = True`
`print('flag2 =', flag2)    # flag2 = False`
`print('flag3 =', flag3)    # flag3 = False`
`print('flag4 =', flag4)    # flag4 = True`
`print('flag5 =', flag5)    # flag5 = False`
说明：比较运算符的优先级高于赋值运算符，所以flag0 = 1 == 1先做1 == 1产生布尔值True，再将这个值赋值给变量flag0。print函数可以输出多个值，多个值之间可以用,进行分隔，输出的内容之间默认以空格分开。

















